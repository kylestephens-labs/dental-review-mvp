#!/usr/bin/env tsx

/**
 * Snippet generator for prove contract compliance
 * Generates VS Code, MCP, and Cursor-specific snippet files from consolidated source
 */

import { writeFileSync, readFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const projectRoot = join(__dirname, '../../..');

interface SnippetSource {
  metadata: {
    version: string;
    description: string;
    lastUpdated: string;
    generatedBy: string;
  };
  snippets: Record<string, {
    prefix: string;
    body: string[];
    description: string;
  }>;
  mcpSnippets: Record<string, {
    name: string;
    description: string;
    parameters: any;
  }>;
  taskTemplates: Record<string, {
    name: string;
    description: string;
    steps: string[];
    requiredFiles: string[];
    proveCommand: string;
  }>;
  cursorRules: {
    title: string;
    description: string;
    rules: string[];
    requiredResponseFormat: string[];
  };
}

/**
 * Generate VS Code snippets file
 */
function generateVSCodeSnippets(source: SnippetSource): string {
  const header = `<!-- 
  Generated by: ${source.metadata.generatedBy}
  Version: ${source.metadata.version}
  Last Updated: ${source.metadata.lastUpdated}
  
  To regenerate: npm run generate-snippets
-->
`;

  const snippets: Record<string, any> = {};
  
  Object.entries(source.snippets).forEach(([key, snippet]) => {
    snippets[snippet.description] = {
      prefix: snippet.prefix,
      body: snippet.body,
      description: snippet.description
    };
  });

  return header + JSON.stringify(snippets, null, 2);
}

/**
 * Generate MCP snippets file
 */
function generateMCPSnippets(source: SnippetSource): string {
  const header = `<!-- 
  Generated by: ${source.metadata.generatedBy}
  Version: ${source.metadata.version}
  Last Updated: ${source.metadata.lastUpdated}
  
  To regenerate: npm run generate-snippets
-->
`;

  const mcpSnippets: Record<string, any> = {};
  
  Object.entries(source.mcpSnippets).forEach(([key, snippet]) => {
    mcpSnippets[snippet.name] = {
      description: snippet.description,
      parameters: snippet.parameters
    };
  });

  return header + JSON.stringify(mcpSnippets, null, 2);
}

/**
 * Generate task templates file
 */
function generateTaskTemplates(source: SnippetSource): string {
  const header = `<!-- 
  Generated by: ${source.metadata.generatedBy}
  Version: ${source.metadata.version}
  Last Updated: ${source.metadata.lastUpdated}
  
  To regenerate: npm run generate-snippets
-->
`;

  const templates: Record<string, any> = {};
  
  Object.entries(source.taskTemplates).forEach(([key, template]) => {
    templates[template.name.toLowerCase().replace(/\s+/g, '-')] = {
      name: template.name,
      description: template.description,
      steps: template.steps,
      requiredFiles: template.requiredFiles,
      proveCommand: template.proveCommand
    };
  });

  return header + JSON.stringify(templates, null, 2);
}

/**
 * Generate Cursor rules file
 */
function generateCursorRules(source: SnippetSource): string {
  const header = `# ${source.cursorRules.title}

<!-- 
  Generated by: ${source.metadata.generatedBy}
  Version: ${source.metadata.version}
  Last Updated: ${source.metadata.lastUpdated}
  
  To regenerate: npm run generate-snippets
-->

${source.cursorRules.description}

## Core Principles
${source.cursorRules.rules.map(rule => `- ${rule}`).join('\n')}

## Required Response Format
\`\`\`
${source.cursorRules.requiredResponseFormat.join('\n')}
\`\`\`

## Task Mode Resolution
1. Determine if task is functional or non-functional
2. Update tasks/TASK.json with correct mode
3. For non-functional: ensure PROBLEM_ANALYSIS.md exists
4. Run prove checks before completion

## Quality Gates
- Trunk: Development on main branch only
- Delivery Mode: Mode resolution and validation
- Commit Message: Conventional commit format
- Kill-switch: Required for feature commits
- Environment: Required environment variables
- Lint: ESLint with zero warnings
- Typecheck: TypeScript compilation
- Tests: Vitest test suite
- TDD: Changed files must have tests (functional)
- Diff Coverage: Coverage on changed lines (functional)
- Problem Analysis: Required sections (non-functional)

## Failure Handling
- Fix all prove failures before proceeding
- Include full error logs in response
- Do not mark task complete without prove success
- Use prove-report.json to identify specific issues

## Environment Variables
- PROVE_MODE: Override task mode
- PROVE_ENABLE_*: Toggle specific checks
- PROVE_JSON: Enable JSON output mode

## Examples

### Functional Task
\`\`\`typescript
// 1. Set mode
const taskMode = 'functional';
// Update TASK.json

// 2. Implement with TDD
// Write tests first, then implementation

// 3. Run prove
exec('npm run prove', (error, stdout, stderr) => {
  // Handle results and include in response
});
\`\`\`

### Non-Functional Task
\`\`\`typescript
// 1. Set mode
const taskMode = 'non-functional';
// Update TASK.json

// 2. Create PROBLEM_ANALYSIS.md
// Ensure all required sections exist

// 3. Run prove
exec('npm run prove', (error, stdout, stderr) => {
  // Handle results and include in response
});
\`\`\`

## Compliance Checklist
- [ ] Task mode determined and set
- [ ] TASK.json updated correctly
- [ ] For non-functional: PROBLEM_ANALYSIS.md created
- [ ] npm run prove executed
- [ ] All prove checks pass
- [ ] Prove logs included in response
- [ ] prove-report.json content pasted
- [ ] Task marked complete only after prove success
`;

  return header;
}

/**
 * Generate agent compliance guide
 */
function generateAgentComplianceGuide(source: SnippetSource): string {
  const content = `# Agent Compliance Guide

<!-- 
  Generated by: ${source.metadata.generatedBy}
  Version: ${source.metadata.version}
  Last Updated: ${source.metadata.lastUpdated}
  
  To regenerate: npm run generate-snippets
-->

This guide ensures all AI agents follow the prove contract compliance requirements.

## Overview

The prove contract system enforces development practices and code quality standards. All tasks must pass prove checks before completion.

## Required Workflow

### 1. Task Mode Resolution
- **Functional Tasks**: Require TDD and diff coverage
- **Non-Functional Tasks**: Require problem analysis documentation

### 2. File Requirements
- **TASK.json**: Must be updated with correct mode
- **PROBLEM_ANALYSIS.md**: Required for non-functional tasks
- **Test Files**: Required for functional tasks (TDD)

### 3. Prove Execution
- Always run \`npm run prove\` before claiming completion
- Include full prove logs in response
- Include prove-report.json content
- Never proceed without passing prove checks

## Response Format

Every task completion must include:

\`\`\`markdown
## Prove Check Results
**Command:** \`npm run prove\`
**Status:** ✅ PASSED / ❌ FAILED

**Logs:**
\`\`\`
[Full prove output here]
\`\`\`

**Report:**
\`\`\`json
[prove-report.json content here]
\`\`\`
\`\`\`

## Quality Gates

The following checks must pass:

- **Trunk**: Development on main branch only
- **Delivery Mode**: Mode resolution and validation
- **Commit Message**: Conventional commit format
- **Kill-switch**: Required for feature commits
- **Environment**: Required environment variables
- **Lint**: ESLint with zero warnings
- **Typecheck**: TypeScript compilation
- **Tests**: Vitest test suite
- **TDD**: Changed files must have tests (functional)
- **Diff Coverage**: Coverage on changed lines (functional)
- **Problem Analysis**: Required sections (non-functional)

## Failure Handling

If prove checks fail:
1. Fix all failures before proceeding
2. Include full error logs in response
3. Do not mark task complete without prove success
4. Use prove-report.json to identify specific issues

## Environment Variables

- \`PROVE_MODE\`: Override task mode
- \`PROVE_ENABLE_*\`: Toggle specific checks
- \`PROVE_JSON\`: Enable JSON output mode

## Compliance Checklist

Before marking any task complete:
- [ ] Task mode determined and set
- [ ] TASK.json updated correctly
- [ ] For non-functional: PROBLEM_ANALYSIS.md created
- [ ] npm run prove executed
- [ ] All prove checks pass
- [ ] Prove logs included in response
- [ ] prove-report.json content pasted
- [ ] Task marked complete only after prove success
`;

  return content;
}

/**
 * Main generation function
 */
function generateSnippets(): void {
  console.log('Generating prove contract compliance snippets...');

  // Load source data
  const sourcePath = join(__dirname, '../snippets/snippet-source.json');
  if (!existsSync(sourcePath)) {
    console.error(`Source file not found: ${sourcePath}`);
    return;
  }

  const source: SnippetSource = JSON.parse(readFileSync(sourcePath, 'utf-8'));

  // Ensure output directories exist
  const vscodeDir = join(projectRoot, '.vscode');
  if (!existsSync(vscodeDir)) {
    mkdirSync(vscodeDir, { recursive: true });
  }

  // Generate VS Code snippets
  const vscodeSnippets = generateVSCodeSnippets(source);
  writeFileSync(join(vscodeDir, 'prove-snippets.code-snippets'), vscodeSnippets);
  console.log('Generated .vscode/prove-snippets.code-snippets');

  // Generate MCP snippets
  const mcpSnippets = generateMCPSnippets(source);
  writeFileSync(join(vscodeDir, 'mcp-prove-snippets.json'), mcpSnippets);
  console.log('Generated .vscode/mcp-prove-snippets.json');

  // Generate task templates
  const taskTemplates = generateTaskTemplates(source);
  writeFileSync(join(vscodeDir, 'task-templates.json'), taskTemplates);
  console.log('Generated .vscode/task-templates.json');

  // Generate agent compliance guide
  const complianceGuide = generateAgentComplianceGuide(source);
  writeFileSync(join(vscodeDir, 'agent-compliance-guide.md'), complianceGuide);
  console.log('Generated .vscode/agent-compliance-guide.md');

  // Generate Cursor rules
  const cursorRules = generateCursorRules(source);
  writeFileSync(join(projectRoot, '.cursorrules'), cursorRules);
  console.log('Generated .cursorrules');

  console.log('Snippet generation complete!');
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  generateSnippets();
}
